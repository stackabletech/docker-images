From d1280d5d0f9fe1de74b47ca48ac0a80b3e1a538a Mon Sep 17 00:00:00 2001
From: Jed Laundry <jlaundry@jlaundry.com>
Date: Fri, 30 Jan 2026 20:36:53 +0000
Subject: Update for azure_* 0.30 crates

Signed-off-by: Jed Laundry <jlaundry@jlaundry.com>
---
 src/sinks/azure_logs_ingestion/config.rs | 34 ++++++++++++++----------
 src/sinks/azure_logs_ingestion/tests.rs  | 25 ++++++++++++-----
 2 files changed, 38 insertions(+), 21 deletions(-)

diff --git a/src/sinks/azure_logs_ingestion/config.rs b/src/sinks/azure_logs_ingestion/config.rs
index a867bf9b6..e39516c4d 100644
--- a/src/sinks/azure_logs_ingestion/config.rs
+++ b/src/sinks/azure_logs_ingestion/config.rs
@@ -1,6 +1,7 @@
 use std::sync::Arc;
 
-use azure_core::credentials::TokenCredential;
+use azure_core::credentials::{TokenCredential, TokenRequestOptions};
+use azure_core::http::ClientMethodOptions;
 use azure_core::{Error, error::ErrorKind};
 
 use azure_identity::{
@@ -193,10 +194,15 @@ struct ManagedIdentityClientAssertion {
 #[cfg_attr(target_arch = "wasm32", async_trait::async_trait(?Send))]
 #[cfg_attr(not(target_arch = "wasm32"), async_trait::async_trait)]
 impl ClientAssertion for ManagedIdentityClientAssertion {
-    async fn secret(&self) -> azure_core::Result<String> {
+    async fn secret(
+        &self,
+        options: Option<ClientMethodOptions<'_>>,
+    ) -> azure_core::Result<String> {
         Ok(self
             .credential
-            .get_token(&[&self.scope], None)
+            .get_token(&[&self.scope], Some(TokenRequestOptions {
+                method_options: options.unwrap_or_default(),
+            }))
             .await?
             .token
             .secret()
@@ -214,22 +220,22 @@ impl AzureAuthentication {
                 azure_client_secret,
             } => {
                 if azure_tenant_id.is_empty() {
-                    return Err(Error::with_message(ErrorKind::Credential, || {
+                    return Err(Error::with_message(ErrorKind::Credential, 
                         "`auth.azure_tenant_id` is blank; either use `auth.azure_credential_kind`, or provide tenant ID, client ID, and secret.".to_string()
-                    }));
+                    ));
                 }
                 if azure_client_id.is_empty() {
-                    return Err(Error::with_message(ErrorKind::Credential, || {
+                    return Err(Error::with_message(ErrorKind::Credential, 
                         "`auth.azure_client_id` is blank; either use `auth.azure_credential_kind`, or provide tenant ID, client ID, and secret.".to_string()
-                    }));
+                    ));
                 }
                 if azure_client_secret.inner().is_empty() {
-                    return Err(Error::with_message(ErrorKind::Credential, || {
+                    return Err(Error::with_message(ErrorKind::Credential, 
                         "`auth.azure_client_secret` is blank; either use `auth.azure_credential_kind`, or provide tenant ID, client ID, and secret.".to_string()
-                    }));
+                    ));
                 }
                 let secret: String = azure_client_secret.inner().into();
-                let credential = ClientSecretCredential::new(
+                let credential: Arc<dyn TokenCredential> = ClientSecretCredential::new(
                     &azure_tenant_id.clone(),
                     azure_client_id.clone(),
                     secret.into(),
@@ -265,9 +271,9 @@ impl AzureAuthentication {
                         if client_assertion_tenant_id.is_none()
                             || client_assertion_client_id.is_none()
                         {
-                            return Err(Error::with_message(ErrorKind::Credential, || {
+                            return Err(Error::with_message(ErrorKind::Credential, 
                                 "`auth.client_assertion_tenant_id` and `auth.client_assertion_client_id` must be set when using `auth.azure_credential_kind` of `managedidentityclientassertion`".to_string()
-                            }));
+                            ));
                         }
 
                         let mut options = ManagedIdentityCredentialOptions::default();
@@ -295,11 +301,11 @@ impl AzureAuthentication {
                         WorkloadIdentityCredential::new(None)?
                     }
                     _ => {
-                        return Err(Error::with_message(ErrorKind::Credential, || {
+                        return Err(Error::with_message(ErrorKind::Credential, 
                             format!(
                                 "`auth.azure_credential_kind` `{azure_credential_kind}` is unknown/unsupported"
                             )
-                        }));
+                        ));
                     }
                 };
                 Ok(credential)
diff --git a/src/sinks/azure_logs_ingestion/tests.rs b/src/sinks/azure_logs_ingestion/tests.rs
index 3e8a1335c..91b4a8fe8 100644
--- a/src/sinks/azure_logs_ingestion/tests.rs
+++ b/src/sinks/azure_logs_ingestion/tests.rs
@@ -1,3 +1,4 @@
+use azure_core::http::ClientOptions;
 use bytes::Bytes;
 use futures::stream;
 use http::Response;
@@ -5,10 +6,11 @@ use std::time::Duration;
 use tokio::time::timeout;
 use vector_lib::config::log_schema;
 
+use azure_core::cloud::{Audiences, CloudConfiguration, CustomConfiguration};
 use azure_core::credentials::{AccessToken, TokenCredential};
-use azure_core::date::OffsetDateTime;
+use azure_core::time::OffsetDateTime;
 use azure_identity::{
-    ClientSecretCredential, ClientSecretCredentialOptions, TokenCredentialOptions,
+    ClientSecretCredential, ClientSecretCredentialOptions,
 };
 
 use super::config::AzureLogsIngestionConfig;
@@ -198,15 +200,24 @@ async fn correct_request() {
     })
     .await;
 
-    let mut credential_options = TokenCredentialOptions::default();
-    //credential_options.set_authority_host("http://127.0.0.1:9001".into());
-    credential_options.set_authority_host(mock_token_authority.to_string());
+    let mut mock_cloud_configuration: CustomConfiguration = CustomConfiguration::default();
+    mock_cloud_configuration.audiences = Audiences::new().with::<String>("http://mock.invalid".to_string());
+    mock_cloud_configuration.authority_host = mock_token_authority.to_string();
+    let cloud_configuration: CloudConfiguration = mock_cloud_configuration.into();
 
     let credential: std::sync::Arc<dyn TokenCredential> = ClientSecretCredential::new(
         "00000000-0000-0000-0000-000000000000",
         "mock-client-id".into(),
         "mock-client-secret".into(),
-        Some(ClientSecretCredentialOptions { credential_options }),
+        Some(ClientSecretCredentialOptions
+            {
+                client_options: ClientOptions
+                {
+                    cloud: Some(std::sync::Arc::new(cloud_configuration)),
+                    ..Default::default()
+                }
+            }
+        ),
     )
     .expect("failed to create ClientSecretCredential");
 
@@ -301,7 +312,7 @@ fn create_mock_credential() -> impl TokenCredential {
         async fn get_token(
             &self,
             _scopes: &[&str],
-            _options: Option<azure_core::credentials::TokenRequestOptions>,
+            _options: Option<azure_core::credentials::TokenRequestOptions<'_>>,
         ) -> azure_core::Result<AccessToken> {
             Ok(AccessToken::new(
                 "mock-access-token".to_string(),
