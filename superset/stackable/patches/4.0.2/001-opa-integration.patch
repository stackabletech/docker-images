diff --git a/superset/security/opa_manager.py b/superset/security/opa_manager.py
new file mode 100644
index 000000000..452d9d322
--- /dev/null
+++ b/superset/security/opa_manager.py
@@ -0,0 +1,95 @@
+import logging
+
+from http.client import HTTPException
+from typing import List, Optional, Tuple
+from flask import current_app, g
+from flask_appbuilder.security.sqla.models import (
+    Role,
+    User,
+)
+from opa_client.opa import OpaClient
+from superset.security import SupersetSecurityManager
+
+class OpaSupersetSecurityManager(SupersetSecurityManager):
+    def get_user_roles(self, user: Optional[User] = None) -> List[Role]:
+        """
+        Retrieves a user's roles from an Open Policy Agent instance updating the
+        user-role mapping in Superset's database in the process.
+
+        :returns: A list of roles.
+        """
+        if not user:
+            user = g.user
+
+        default_role = self.resolve_role(
+            current_app.config.get("AUTH_USER_REGISTRATION_ROLE")
+            )
+
+        opa_role_names = self.get_opa_user_roles(user.username)
+        logging.info('OPA returned roles: %s', opa_role_names)
+
+        opa_roles = set(map(self.resolve_role, opa_role_names))
+        logging.info('Resolved OPA Roles in Database: %s', opa_roles)
+        # Ensure that in case of a bad or no response from OPA each user will have
+        # at least one role.
+        if opa_roles == {None} or opa_roles == set():
+            opa_roles = {default_role}
+
+        if set(user.roles) != opa_roles:
+            logging.info('Found a diff between %s (Superset) and %s (OPA).',
+                    user.roles, opa_roles)
+            user.roles = list(opa_roles)
+            self.update_user(user)
+
+        return user.roles
+
+
+    def get_opa_user_roles(self, username: str) -> set[str]:
+        """
+        Queries an Open Policy Agent instance for the roles of a given user.
+
+        :returns: A list of role names or an empty list if an exception during
+        the connection to OPA is encountered or if OPA didn't return a list.
+        """
+        host, port, tls = self.resolve_opa_base_url()
+        client = OpaClient(host = host, port = port, ssl = tls)
+        try:
+            response = client.query_rule(
+                  input_data = {'username': username},
+                  package_path = current_app.config.get('STACKABLE_OPA_PACKAGE'),
+                  rule_name = current_app.config.get('STACKABLE_OPA_RULE'))
+        except HTTPException as exception:
+            logging.error('Encountered an exception while querying OPA:%s', exception)
+            return []
+        roles = response.get('result')
+        # If OPA didn't return a result or if the result is not a list, return no roles.
+        if roles is None or type(roles).__name__ != "list":
+            logging.error('The OPA query didn\'t return a list: %s', response)
+            return []
+        return roles
+
+
+    def resolve_opa_base_url(self) -> Tuple[str, int, bool]:
+        """
+        Extracts connection parameters of an Open Policy Agent instance from config.
+
+        :returns: Hostname, port and protocol (http/https).
+        """
+        opa_base_path = current_app.config.get('STACKABLE_OPA_BASE_URL')
+        [protocol, host, port] = opa_base_path.split(":")
+        # remove any path be appended to the base url
+        port = int(port.split('/')[0])
+        return host.lstrip('/'), port, protocol == 'https'
+
+
+    def resolve_role(self, role_name: str) -> Role:
+        """
+        Finds a role by name creating it if it doesn't exist in Superset yet.
+
+        :returns: A role.
+        """
+        role = self.find_role(role_name)
+        if role is None:
+            logging.info('Creating role %s as it doesn\'t already exist.', role_name)
+            self.add_role(role_name)
+        return self.find_role(role_name)
diff --git a/tests/unit_tests/security/opa_manager_test.py b/tests/unit_tests/security/opa_manager_test.py
new file mode 100644
index 000000000..b65d88b19
--- /dev/null
+++ b/tests/unit_tests/security/opa_manager_test.py
@@ -0,0 +1,222 @@
+# pylint: disable=invalid-name, unused-argument, redefined-outer-name
+
+import pytest
+from flask_appbuilder.security.sqla.models import User
+from pytest_mock import MockFixture
+
+from superset.extensions import appbuilder
+from superset.security.opa_manager import OpaSupersetSecurityManager
+
+
+def test_opa_security_manager(app_context: None) -> None:
+    """
+    Test that the OPA security manager can be built.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    assert sm
+
+
+@pytest.fixture
+def user() -> User:
+    """
+    Return a user.
+    """
+    user = User()
+    user.id = 1234
+    user.first_name = 'mock'
+    user.last_name = 'mock'
+    user.username = 'mock'
+    user.email = 'mock@mock.com'
+
+    return user
+
+
+def test_add_roles(
+    mocker: MockFixture,
+    app_context: None,
+    user: User,
+) -> None:
+    """
+    Test that roles are correctly added to a user.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    opa_roles = ['Test1', 'Test2', 'Test3']
+    mocker.patch(
+        'flask_appbuilder.security.sqla.manager.SecurityManager.update_user',
+        return_value = True
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.get_opa_user_roles',
+        return_value = opa_roles
+    )
+
+    assert set(sm.get_user_roles(user)) == set(map(sm.resolve_role, opa_roles))
+
+
+def test_change_roles(
+    mocker: MockFixture,
+    app_context: None,
+    user: User,
+) -> None:
+    """
+    Test that roles are correcty changed on a user.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    opa_roles = ['Test4']
+    mocker.patch(
+        'flask_appbuilder.security.sqla.manager.SecurityManager.update_user',
+        return_value = True
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.get_opa_user_roles',
+        return_value = opa_roles
+    )
+    user_roles = ['Test1', 'Test2', 'Test3']
+    user.roles = list(map(sm.resolve_role, user_roles))
+
+    assert set(sm.get_user_roles(user)) == set(map(sm.resolve_role, opa_roles))
+
+
+def test_no_roles(
+    mocker: MockFixture,
+    app_context: None,
+    user: User,
+) -> None:
+    """
+    Test that only the default role is assigned if OPA returns no roles.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    opa_roles = []
+    mocker.patch(
+        'flask_appbuilder.security.sqla.manager.SecurityManager.update_user',
+        return_value = True
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.get_opa_user_roles',
+        return_value = opa_roles
+    )
+    default_role = sm.resolve_role('Public')
+
+    assert set(sm.get_user_roles(user)) == {default_role}
+
+
+def test_roles_not_created(
+    mocker: MockFixture,
+    app_context: None,
+    user: User,
+) -> None:
+    """
+    Test that only the default role is assigned if a new role can't be created in the DB.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    opa_roles = ['Test5', 'Test6']
+    mocker.patch(
+        'flask_appbuilder.security.sqla.manager.SecurityManager.update_user',
+        return_value = True
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.get_opa_user_roles',
+        return_value = opa_roles
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.add_role',
+        return_value = None
+    )
+    default_role = sm.resolve_role('Public')
+
+    assert set(sm.get_user_roles(user)) == {default_role}
+
+
+def test_get_opa_roles(
+    mocker: MockFixture,
+    app_context: None,
+) -> None:
+    """
+    Test that roles are correctly extracted from the OPA response.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    roles = ['Test1', 'Test2', 'Test3']
+    response = {'result': roles}
+    mocker.patch(
+        'opa_client.opa.OpaClient.query_rule',
+        return_value = response
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.resolve_opa_base_url',
+        return_value = ('opa-instance', 8081, False)
+    )
+
+    assert sm.get_opa_user_roles('User1') == roles
+
+
+def test_get_opa_roles_no_result(
+    mocker: MockFixture,
+    app_context: None,
+) -> None:
+    """
+    Test that no roles are returned if the OPA response doesn't contain a query result.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    response = {'error': 'error occurred'}
+    mocker.patch(
+        'opa_client.opa.OpaClient.query_rule',
+        return_value = response
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.resolve_opa_base_url',
+        return_value = ('opa-instance', 8081, False)
+    )
+
+    assert sm.get_opa_user_roles('User1') == []
+
+
+def test_get_opa_roles_not_a_list(
+    mocker: MockFixture,
+    app_context: None,
+) -> None:
+    """
+    Test that no roles are returned if the query result doesn't contain a list.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    response = {'result': "['Test1', 'Test2', 'Test3']"} # type string not list
+    mocker.patch(
+        'opa_client.opa.OpaClient.query_rule',
+        return_value = response
+    )
+    mocker.patch(
+        'superset.security.opa_manager.OpaSupersetSecurityManager.resolve_opa_base_url',
+        return_value = ('opa-instance', 8081, False)
+    )
+
+    assert sm.get_opa_user_roles('User1') == []
+
+
+def test_resolve_opa_base_url(
+    mocker: MockFixture,
+    app_context: None,
+) -> None:
+    """
+    Test that only OPA base URL parts correctly resolved from the config.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    mocker.patch(
+        'flask.current_app.config.get',
+        return_value = 'http://opa-instance:8081'
+    )
+    assert sm.resolve_opa_base_url() == ('opa-instance', 8081, False)
+
+
+def test_resolve_opa_base_url_with_path(
+    mocker: MockFixture,
+    app_context: None,
+) -> None:
+    """
+    Test that only OPA base URL parts correctly resolved from the config when the URL
+    also contains a path.
+    """
+    sm = OpaSupersetSecurityManager(appbuilder)
+    mocker.patch(
+        'flask.current_app.config.get',
+        return_value = 'http://opa-instance:8081/v1/data/superset'
+    )
+    assert sm.resolve_opa_base_url() == ('opa-instance', 8081, False)
